<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link rel="icon" type="image/x-icon" href="C:\Users\Lenovo\3D Objects\DINSHA PATEL COLLEGE OF COMPUTER SCIENCE\PROJECTS\Maze\farhan.png">
  <title>Maze Puzzle</title>
  <style>
    canvas {
      background-color: white;
      display: block;
      margin: 0 auto;
      border: 2px solid black;
    }
    body {
  margin: 0;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #2e2e2e;
}
  button {
    font-size: 24px;
    padding: 15px 25px;
    margin: 5px;
    cursor: pointer;
  }

  @media (hover: none) {
    button {
      width: 60px;
      height: 60px;
    }
  }

  </style>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h1>FARHAN GAME </h1>

<canvas id="maze" width="500" height="500"></canvas>
<div style="text-align:center; margin-top: 20px;">
  <div>
    <button onclick="movePlayer(0, -1)">⬆️</button>
  </div>
  <div>
    <button onclick="movePlayer(-1, 0)">⬅️</button>
    <button onclick="movePlayer(1, 0)">➡️</button>
  </div>
  <div>
    <button onclick="movePlayer(0, 1)">⬇️</button>
  </div>
</div>


<script>
  const canvas = document.getElementById("maze");
  const ctx = canvas.getContext("2d");

  const cols = 10;
  const rows = 10;
  const cellSize = canvas.width / cols;
  const grid = [];
  let current;
  const stack = [];

  class Cell {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.walls = [true, true, true, true]; // top, right, bottom, left
      this.visited = false;
    }

    draw() {
      const x = this.x * cellSize;
      const y = this.y * cellSize;

      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;

      if (this.walls[0]) drawLine(x, y, x + cellSize, y); // top
      if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize); // right
      if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize); // bottom
      if (this.walls[3]) drawLine(x, y + cellSize, x, y); // left

      if (this.visited) {
        ctx.fillStyle = "#ddd";
        ctx.fillRect(x, y, cellSize, cellSize);
      }
    }

    highlight() {
      const x = this.x * cellSize;
      const y = this.y * cellSize;
      ctx.fillStyle = "limegreen";
      ctx.fillRect(x, y, cellSize, cellSize);
    }

    checkNeighbors() {
      const neighbors = [];

      const top = grid[index(this.x, this.y - 1)];
      const right = grid[index(this.x + 1, this.y)];
      const bottom = grid[index(this.x, this.y + 1)];
      const left = grid[index(this.x - 1, this.y)];

      if (top && !top.visited) neighbors.push(top);
      if (right && !right.visited) neighbors.push(right);
      if (bottom && !bottom.visited) neighbors.push(bottom);
      if (left && !left.visited) neighbors.push(left);

      if (neighbors.length > 0) {
        const r = Math.floor(Math.random() * neighbors.length);
        return neighbors[r];
      } else {
        return undefined;
      }
    }
  }

  function index(x, y) {
    if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
    return x + y * cols;
  }

  function drawLine(x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  function removeWalls(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    if (dx === 1) {
      a.walls[3] = false;
      b.walls[1] = false;
    } else if (dx === -1) {
      a.walls[1] = false;
      b.walls[3] = false;
    }

    if (dy === 1) {
      a.walls[0] = false;
      b.walls[2] = false;
    } else if (dy === -1) {
      a.walls[2] = false;
      b.walls[0] = false;
    }
  }

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      grid.push(new Cell(x, y));
    }
  }

  current = grid[0];

  function generateMaze() {
    current.visited = true;
    const next = current.checkNeighbors();

    if (next) {
      next.visited = true;
      stack.push(current);
      removeWalls(current, next);
      current = next;
    } else if (stack.length > 0) {
      current = stack.pop();
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (const cell of grid) {
      cell.draw();
    }

    current.highlight();

    if (stack.length > 0) {
      requestAnimationFrame(generateMaze);
    } else {
      drawPlayer();
    }
  }

  // Draw the player
  let player = { x: 0, y: 0 };
  const goal = { x: cols - 1, y: rows - 1 };

  function drawPlayer() {
    ctx.fillStyle = "blue";
    ctx.fillRect(player.x * cellSize + 5, player.y * cellSize + 5, cellSize - 10, cellSize - 10);

    // Draw goal
    ctx.fillStyle = "red";
    ctx.fillRect(goal.x * cellSize + 10, goal.y * cellSize + 10, cellSize - 20, cellSize - 20);
  }

  function movePlayer(dx, dy) {
    const currentCell = grid[index(player.x, player.y)];
    const newX = player.x + dx;
    const newY = player.y + dy;
    const nextCell = grid[index(newX, newY)];

    if (!nextCell) return;

    const dir = dx === 1 ? 1 : dx === -1 ? 3 : dy === 1 ? 2 : 0;

    if (!currentCell.walls[dir]) {
      player.x = newX;
      player.y = newY;
    }

    // Redraw maze
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const cell of grid) {
      cell.draw();
    }
    drawPlayer();

    if (player.x === goal.x && player.y === goal.y) {
      setTimeout(() => alert("You reached the goal!"), 100);
    }
  }

  document.addEventListener("keydown", (e) => {
    switch (e.key) {
      case "ArrowUp": movePlayer(0, -1); break;
      case "ArrowDown": movePlayer(0, 1); break;
      case "ArrowLeft": movePlayer(-1, 0); break;
      case "ArrowRight": movePlayer(1, 0); break;
    }
  });


  generateMaze();
</script>

</body>
</html>


